// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "SetShooterSpeed.h"
#include <math.h>

#define THRESHOLD    50.0
#define MAX_VALUE  3500.0
#define MIN_VALUE     0.0

SetShooterSpeed::SetShooterSpeed(double speed, bool isRPM) 
{
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::shooterWheel);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	
	// remember the desired shooter speed
	m_shooterSpeed = speed;
	
	// indicate that the speed was specified in the constructor
	m_SpeedSpecifiedInConstructor = true;
	m_isRPM = isRPM;
}
SetShooterSpeed::SetShooterSpeed() 
{
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::shooterWheel);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	
	SmartDashboard::PutNumber("Shooter speed", 0.0);
	
	// indicate that the speed was not specified in the constructor
	m_SpeedSpecifiedInConstructor = false;
}
// Called just before this Command runs the first time
void SetShooterSpeed::Initialize() 
{
	    // determine if the shooter speed should be read from the Pot
		if (m_SpeedSpecifiedInConstructor == true) // use speed specified
		{
		  // read the desired shooter RPM from the constructor
			Robot::shooterWheel->getPIDController()->SetSetpoint(m_shooterSpeed);
			
			// Voltage or PID control
			if(m_isRPM == false)
			{
				// Voltage Mode
				Robot::shooterWheel->getPIDController()->Disable();
			}
			else
			{
				Robot::shooterWheel->getPIDController()->SetSetpoint(m_shooterSpeed);

			    // enable the PID controller
			    Robot::shooterWheel->getPIDController()->Enable(); 
			}
		}
		else // values should be read from pot
		{
			
			m_isRPM = ;
			
			// Voltage or PID control
			if(m_isRPM == false)
			{
				// Voltage Mode
				Robot::shooterWheel->getPIDController()->Disable();
			}
			else
			{
			   // read the value from the pot
				m_shooterSpeed = 	DriverStation::GetInstance()->GetEnhancedIO().GetAnalogIn(ANALOG_SHOOTER_SPEED);
				
				// Convert the pot value to speed
				m_shooterSpeed = m_shooterSpeed*(MAX_VALUE - MIN_VALUE)/3.3 + MIN_VALUE;
				
				// Set the setpoint
				Robot::shooterWheel->getPIDController()->SetSetpoint(m_shooterSpeed);

			    // enable the PID controller
			    Robot::shooterWheel->getPIDController()->Enable(); 
			}
		}
}
// Called repeatedly when this Command is scheduled to run
void SetShooterSpeed::Execute() 
{
    // determine if the shooter speed should be read from the Pot
	if (m_SpeedSpecifiedInConstructor == true) // use speed specified
	{
		if(m_isRPM == false)
		{
			Robot::shooterWheel->motor->Set(m_shooterSpeed);
		}
	}
	else // Use pot to control
	{
		if()
	}
		
	float shooterVoltage = Robot::oi->getShootJoystick()->GetZ();
	shooterVoltage = (shooterVoltage + 1.0) / 2.0;	
	Robot::shooterWheel->SetWheelSpeed(shooterVoltage);
	
}
// Make this return true when this Command no longer needs to run execute()
bool SetShooterSpeed::IsFinished() 
{
    // determine is the shooter speed is within the desired limit
	return fabs(m_shooterSpeed - Robot::shooterWheel->pidEncoder->PIDGet()) < THRESHOLD;	
}
// Called once after isFinished returns true
void SetShooterSpeed::End() 
{
	// not disabling because we always want the shooter to keep running
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void SetShooterSpeed::Interrupted()
{
	// not disabling because we always want the shooter to keep running
	// ideally when interrupting it should reset to previous value but is probably overkill
}
